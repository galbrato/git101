Comandos do terminal:
cd <caminho apra pasta>
	cd muda a localisacao para o caminho apssado por argumento
cd ..
	volta para pasta anterior
mkdir <nome_da_pasta>
	cria pasta com nome passado por argumento
ls
	Lista todos os arquivos dentor da pasta atual
nano <nome do arquivo texto>
	abre um editor de texto no terminal
[crtl] l
	limpa o terminal
rm <nome do arquivo>
	deleta o arquivo apssado por parametro

Comandos do git

git init
	Torna a pasta atual em um remositorio git, criando o sistemas de arquivos '.git/'

git status
	Mostrar informaçoes como a sua branch atual, alterações a serem "salvas"(commitadas) na sua pasta, arquivos que não estao trackeds

git add <nome do arquivo a ser comitado>
	Adiciona o arquivo passado por parametro ao seu pacote que AINDA sera comittado("salvado")
	se o arquivo for modificado, deletado, alterado de qualquer forma, ainda tera que ser adicionado com este comando para ser commitado 

git commit
	Abrir um editor de texto para documentar o seu commit, e ira salvar todos os arquivos adicionados com o comando "git add <nome>". 

git commit -m "<texto de documentação>"
	faz o commit sem abrir o editor de texto, e coloca a mensagem passada pro aprametro como a documentação do commit, NOTA: as aspas são parte do comando

git log
	Lista todos os commits feitos

git log --graph --all --abbrev-commit --decorate --oneline
	Pritna os commit em forma de arvore
	
git show <hash do commit a ser mostrado>
	mostra todas as alterações feitas naquele commit
git show <nome_do_arquivo>
	mostrar modificações feitas naquele arquivo no commit atual

git branch
	lista branchs e qual vc esta

git branch <nome_da_branch_a_ser_criada>
	Cria uma branch com aquele nome

git branch -D <nome>
	deleta a o ponteiro branch com o nome passado por parametro

git checkout <nome da brnach>
	MUda a HEAD para a branch passada por parametro,lembrando... mesma coisa que outro checkout

git checkout <hash_deum_commit>
	muda o ponteiro HEAD para um commit identificado pela hash, lembrando que muda o estado do projeto apra o estado que tava naquele  komento do commit

.gitignore
	NAO É UM COMANDO
	arquivo com nomes dos arquivos que o git deve ignorar

git merge <nome_da_branch_que_voce_vai_pegar_as_alterações>
	cria um novo commit que vai ser o merge do commit ATUAL e do apontado pela branch passada por parametro, e pega o branch atual e aponta para esse novo commit
git merge <hash_de_um_commit>
	cria um novo commit que vai ser o merge do commit ATUAL e do commit identificado pela hash passada por parametro, e pega o branch atual e aponta para esse novo commit

============ SE DEU CONFLITO =========
para escolher entre uma versão d eum arquivo de uma branch ou de outra usar:
git checkout --theirs <nome do arquivo>
	ignorar a versão da HEAD e pegar a versão do commit que esta sendo mergeado
git checkout --ours <nome do arquivo>
	ignorar a versão do commit mergeado e pegar a versão da HEAD

se quiser criar uma versão intermediaria do merge tera que abrir o arquivo que estara com os conflitos delimitados por: 
	HEAD <<<<<<
	<trecho de codigo que estava na HEAD>
	===========
	<trecho de codigo que estava no comiit mergeado>
	>>>>>>>>>>
(lembrando tem que aiodna dar git add e commit dos arquivos modificados para terminar o merge)
=========================================
COMANDOS COM O GIT HUB

git remote add <nome_do_repositorio_remote> <URL>
	linka o repositorio atual com um repositorio remoto, e da localmente um apelido para o remositorio remoeto que voce -SEMPRE- vai chamar de origin
	OBS: <nome_do_repositorio_remote> = origin
git clone <URL>
	faz download do remositorio do git hub especificado pela URL
git fetch
	Sincroniza a arvore de commits locais com a arvore de commits remota
git push <apelido_do_repo_remoto> <nome_da_branch_remota>
	pegas os commits atuais e salva na branch especificada pelo nome
	o apelido da remota geralmnete vai ser origin
	Obs: se a branch remotar não existir ela sera criada com o nome passado, tente manter os nomes iguais a sua branch local
